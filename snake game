from random import randrange, choice  # Import choice for random power-up selection
from turtle import update, onkey, clear, ontimer, setup, hideturtle, tracer, listen, done, textinput, bgcolor, title, write, up, down, setposition
from freegames import square, vector
#AO import keyboard module
#Reference: https://stackoverflow.com/questions/24072790/how-to-detect-key-presses
#BEFORE RUNNING - type "pip install keyboard" into Anaconda Prompt
import keyboard

food = vector(0, 0)
snake = [vector(10, 0)]
aim = vector(0, -10)

#IM Initializes the score value to 0
score = 0

#GS Initialize a wall list to add walls to 
wall = [vector(40,-60)]

#GS initialize a power up position
powerup = vector(0 , 0) 

#GS initialize a variable to check if powerup is on or not
powerup_on = False 

#GS initialize a speed multiplier for the snake so it's easy to change with speed powerups
speed_product= 1

#AP initialize a variable to check type of powerup
powerup_type = ''

#GS initialize a variable to check if the shorten powerup was just used - so the game does not spawn another powerup at length 5
just_shortened = False
            
# Game state
game_running = False

#IM Function to display the start page
def start_page():
    clear()
    write('SNAKE GAME', align='center', font=('Futura', 30, 'bold'))
    up()
    setposition(0,-25)
    down()
    write('Use Arrow keys or WASD to control the snake',align='center', font=('Futura', 16, 'normal'))
    up()
    setposition(0,-50)
    down()
    write('Press Enter to Start', align='center', font=('Futura', 16, 'normal'))
    update()

#IM Function to display the end game page
def end_page():
    clear()
    up()
    setposition(0,0)
    down()
    write('GAME OVER', align='center', font=('Futura', 30, 'bold'))
    up()
    setposition(0,-25)
    down()
    write(f'Final Score: {score}', align='center', font=('Futura', 20, 'normal'))
    up()
    setposition(0,-50)
    down()
    write('Press Enter to Restart', align='center', font=('Futura', 16, 'normal'))
    update()

def change(x, y):
    """Change snake direction."""
    aim.x = x
    aim.y = y

def inside(head):
    """Return True if head inside boundaries."""
    return -200 < head.x < 190 and -200 < head.y < 190

def draw_powerup(powerup_type):
    #GS apply a specific colour to each type of powerup
    if powerup_type == 'speed_up' :
        square(powerup.x, powerup.y, 9, 'purple')
    elif powerup_type == 'speed_down' :
        square(powerup.x, powerup.y, 9, 'blue')
    elif powerup_type == 'shorten':
        square(powerup.x, powerup.y, 9, 'yellow')
    elif powerup_type == 'lengthen' :
        square(powerup.x, powerup.y, 9, 'pink')
        
#AP function to check whether a provided object intersects with another
def check_intersection(thing, category):
    #AP conditionals decide which checks are necessary.
    #AP E.G. food does not reference food location as they will always be the same
    if category!='food':
        if thing.x == food.x and thing.y == food.y:
            #AP returns true if the obejcts intersect
            return True
    
    for s in wall:
        if thing.x == s.x and thing.y == s.y:
            return True
    
    if category != 'snake':
        for s in snake:
            if thing.x == s.x and thing.y == s.y:
                return True
            
     #AP returns false if no objects intersect   
    return False

def move():
    #GS Define global variables that will be used inside the functions 
    global speed_product 
    global powerup_on
    global powerup_type
    global just_shortened
    global score

    """Move snake forward one segment."""
    head = snake[-1].copy()
    head.move(aim)

    #GS Add to check if the head hits the wall to end the game #IM display eng game page when head hits wall
    if not inside(head) or head in snake or head in wall:
        square(head.x, head.y, 9, 'red')
        update()
        ontimer(end_game,800)
        return

    snake.append(head)

    if head == food:
        #IM score will update by 1 when head eats food
        score += 1
        #GS check if the shortened powerup was used
        just_shortened = False
        #GS keep the speed multiplier at normal speed when another powerup appears
        if len(snake)%5 == 0:
            speed_product = 1
        print('Snake:', len(snake))
        #AP turn powerup off
        powerup_on = False
        #GS make sure food is not in wall 
        while(True):
            cond = False
            food.x = randrange(-15, 15) * 10
            food.y = randrange(-15, 15) * 10
            
            cond = check_intersection(food, "food")
                    
            if not cond:
                break
                    
        
        #AP Create a random wall after food is eaten
        new_wall = wall[-1].copy() 
        while(True):
            cond = False
            new_wall.x = randrange(-20, 19) * 10
            new_wall.y = randrange(-20, 19) * 10
           
            cond = check_intersection(new_wall, "wall")
            
            if not cond:
                break

        
        wall.append(new_wall)
    #GS Check if the snake eats the powerup
    elif head == powerup and powerup_on == True:
        speed_product = 1
        #GS Check the type of powerup and applies the powerup
        if powerup_type == 'speed_up' :
            speed_product /= 2
        elif powerup_type == 'speed_down':
            speed_product += 1
        elif powerup_type == 'shorten':
            if len(snake)>5 :
                for i in range(3):
                    snake.pop(i)
                just_shortened = True
        elif powerup_type == 'lengthen' :
            for i in range(3):
                head = snake[-1].copy()
                head.move(aim)
                snake.append(head)
        #GS Reset the powerup status 
        powerup_on = False
        #AP Move the food to a new place after powerup is eaten
        while(True):
            cond = False
            food.x = randrange(-15, 15) * 10
            food.y = randrange(-15, 15) * 10
           
            cond = check_intersection(food, "food")
                
            if not cond:
                break
    else:
        snake.pop(0)

    clear()

    for body in snake:
        square(body.x, body.y, 9, 'black')

    square(food.x, food.y, 9, 'green')
    
    #Apply a colour to walls
    for i in wall: 
    
        square(i.x, i.y, 9, 'grey')
    
    #AP Check if you want powerup to appear and make sure it doesn't appear at the same length twice if shortened powerup was used 
    if (len(snake))%5 == 0 and not just_shortened :
        if not powerup_on:
            #GS turn the powerup on
            powerup_on = True
            #GS Pick powerup type
            powerup_type = choice(['speed_up', 'speed_down', 'shorten', 'lengthen'])
            #GS pick new powerup location and make sure it is not inside a wall
            while(True):
                cond = False
                powerup.x = randrange(-15, 15) * 10
                powerup.y = randrange(-15, 15) * 10
                
                cond = check_intersection(powerup, "powerup")
                
                draw_powerup(powerup_type)
                
                if not cond:
                    break
            
        else: 
           draw_powerup(powerup_type)
        
    update()
    #GS Change ontimer time value to be a function of speed multiplier
    ontimer(move, int(100 *speed_product))
    
def controlSnake():
    #AO User input for snake using arrows or 'wasd'
    #AO snake will go right if 'd' or the right arrow is pressed
    if keyboard.is_pressed("d") or keyboard.is_pressed("right arrow"):
        #AO snake can go in all directions if length is 1
        if len(snake) == 1:
            change(10,0)
        else:
            #AO snake cannot go right if it is already going left
            if aim != vector(-10,0):
                change(10,0)
            
    #AO snake will go left if 'a' or the left arrow is pressed
    if keyboard.is_pressed("a") or keyboard.is_pressed("left arrow"):
        if len(snake) == 1:
            change(-10,0)
        else:
            #AO snake cannot go left if it is already going right
            if aim != vector(10,0):
                change(-10,0)

    #AO snake will go up if 'w' or the up arrow is pressed
    if keyboard.is_pressed("w") or keyboard.is_pressed("up arrow"):
        if len(snake) == 1:
            change(0,10)
        else:    
            #AO snake cannot go up if it is already going down
            if aim != vector(0,-10):
                change(0,10)
    
    #AO snake will go down if 's' or the down arrow is pressed
    if keyboard.is_pressed("s") or keyboard.is_pressed("down arrow"):
        if len(snake) == 1:
            change(0,-10)
        else:    
            #AO snake cannot go down if it is already going up
            if aim != vector(0,10):
                change(0,-10)

#IM Function to start game
def start_game():
    global game_running, snake, food, aim, score, wall, powerup_on, speed_product, just_shortened
    game_running = True
    snake = [vector(10,0)] #IM this will reset the snake
    food = vector(0,0) #IM this will reset food
    aim = vector(0,-10) #IM Reset the direction
    score = 0 #IM reset the score when starting the game
    wall = [vector(40,-60)]  # IM Reset walls to initial state
    powerup_on = False  # IM Reset powerup state
    speed_product = 1  # IM Reset speed
    just_shortened = False  # IM Reset shortened state
    move()
    
#IM Function to end the game
def end_game():
    global game_running
    game_running = False
    end_page()
    
#IM function to restart the game
def restart_game():
    if not game_running:
        start_game()

setup(420, 420, 370, 0)
hideturtle()
tracer(False)
listen()
onkey(lambda: start_game(), 'Return') #IM Press enter to start the game
onkey(lambda: restart_game(), 'Return') #IM press enter to restart the game]
start_page() #IM show start page
done()
